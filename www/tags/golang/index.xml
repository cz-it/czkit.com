<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on CZKit</title>
    <link>http://www.czkit.com/tags/golang/</link>
    <description>Recent content in Golang on CZKit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="http://www.czkit.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Debugging Go Code with GDB [译]</title>
      <link>http://www.czkit.com/golang/translate/debugging_go_code_with_gdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.czkit.com/golang/translate/debugging_go_code_with_gdb/</guid>
      <description>一篇很老的文章，最近翻来看，好像也没人翻译，随手翻译一遍，文章来自Golang&amp;rsquo;s Blog
  以下说明适用于Golang的标准工具链（Go编译器如gc以及其他工具），GccGo有他自己的gdb支持。
需要注意的是，对于使用标准工具链构建的Golang来说Delve相比如GDB是一个更好的选择，Delve可以更好的理解Go的运行时、数据结构以及表达式等。当前Delve可以支持Linux、OSX以及arm64平台下的Windows，最新能支持的平台列表参见Delve的文档
GDB并不能很好理解Go程序，比如栈管理、线程以及包含了和传统GDB执行模型不一样的运行时，即便是通过gccgo来编译的程序有时候也会产生让人迷惑的信息。总的来说，虽然GDB可以在一些场景（如调试Cgo代码或者调试运行时）起到定位问题的作用，但它不是Go赖以生存的调试器，尤其是对于并发场景。或者说GDB不是Go程序首选的调试器。
所以，下面的篇幅只是当你用GDB时候的一个指引，但是并不保证一定成功。除此之外，还可以参考GDB手册
简介 当在Linux/Mac OS X/FreeBSD 或者NetBSD等系统上通过gc工具链编译Go程序构建出来的二进制文件包含了 DWARFv4 调试信息可以用于GDB(需要版本大于等于7.5）调试一个运行中的进程或者Core文件。
在连接的时候，可以传递&amp;rdquo;-w&amp;rdquo;选项来省略调试信息（举例：go build -ldflags=-w prog.go）。
gc编译器生成的代码在每一行包含了函数的调用和注册表信息，这些选项有时候会使得通过gdb调试起来变得困难，所以如果需要去除这些优化的话，可以在构建时使用go build -gcflags=all=&amp;quot;-N -l&amp;quot;.
如果想通过GDB调试一个程序的core文件，需要在程序崩溃的时候触发生成一个dump文件，此时需要设置环境变量GOTRACEBACK=crash（更多信息参考runtime package documentation）。
一般操作  显示文件代码或指定行号代码并设置和取消断点：
(gdb) list (gdb) list line (gdb) list file.go:line (gdb) break line (gdb) break file.go:line (gdb) disas  显示断点和栈信息
(gdb) bt (gdb) frame n  在栈帧中显示本地变量、参数、返回值的名称、类型位置等
(gdb) info locals (gdb) info args (gdb) p variable (gdb) whatis variable  显示全局变量的名称、类型和位置</description>
    </item>
    
  </channel>
</rss>